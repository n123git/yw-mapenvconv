<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>yw-mapenvconv</title>
</head>
<body>
  <h1>yw-mapenvconv</h1> <!-- this is THE MOST CONVOLUTED PROJECT IVE DONE IN SO LONG - OH MY G- :<<<-->

  <input id="file-yw2" type="file" accept="application/json" />
  <button id="convert">Convert</button>
  <select id="convert-mode">
    <option value="yw3">YW3</option>
    <option value="ywb">YWB</option>
  </select>

  <a id="download" style="display:none">Download result</a>
  <pre id="preview">No preview yet</pre>

<script>

// --- labels ---
const LABELS_YW3 = [ /* yes yw2 is the official acronym :> */
  "ActivationCond|False",
  "BtlMapID|False",
  "MapEffectMORNING_DAY?|False",
  "MapEffectEVENING?|False",
  "MapEffectNIGHT?|False",
  "MapEffectRAIN?|False",
  "MapEffectFORCE?|False",
  "MMScroll|False",
  "MMModelPos-X?|False",
  "MMModelPos-Y?|False",
  "MMModelPos-Z?|False",
  "MMModelPos-ROT?|False",
  "UnkX??????|False",
  "UnkY??????|False",
  "UnkZ??????|False",
  "UnkRot??????|False",
  "MMViewSize-PixelsX|False",
  "MMViewSize-PixelsY|False",
  "CameraFOV|False",
  "CameraDist|False",
  "CameraRotH|False",
  "CameraRotV|False",
  "CameraRotUnk|False",
  "CameraRotAlsoUnk|False",
  "DptRngRate|False",
  "DptLvl|False",
  "Near|False",
  "Far|False",
  "LIGHTMapLight|False",
  "LIGHTBGColorNormalisedR|False",
  "LIGHTBGColorNormalisedG|False",
  "LIGHTBGColorNormalisedB|False",
  "ShadowColsdw01-NormalisedR|False",
  "ShadowColsdw01-NormalisedG|False",
  "ShadowColsdw01-NormalisedB|False",
  "ShadowColsdw02-NormalisedR|False",
  "ShadowColsdw02-NormalisedG|False",
  "ShadowColsdw02-NormalisedB|False",
  "ShadowColsdw03-NormalisedR|False",
  "ShadowColsdw03-NormalisedG|False",
  "ShadowColsdw03-NormalisedB|False",
  "ShadowColsdw04-NormalisedR|False",
  "ShadowColsdw04-NormalisedG|False",
  "ShadowColsdw04-NormalisedB|False",
  "ShadowColsdw05-NormalisedR|False",
  "ShadowColsdw05-NormalisedG|False",
  "ShadowColsdw05-NormalisedB|False",
  "DEF_POSX?|False",
  "DEF_POSY?|False",
  "DEF_POSZ?|False",
  "DEF_POSROT?|False",
  "INDOOR-BooleanIsIndoors|False",
  "WEATHERSUN_MCLR-NormalisedR|False",
  "WEATHERSUN_MCLR-NormalisedG|False",
  "WEATHERSUN_MCLR-NormalisedB|False",
  "WEATHERSUN_DCLR-NormalisedR|False",
  "WEATHERSUN_DCLR-NormalisedG|False",
  "WEATHERSUN_DCLR-NormalisedB|False",
  "WEATHERSUN_ECLR-NormalisedR|False",
  "WEATHERSUN_ECLR-NormalisedG|False",
  "WEATHERSUN_ECLR-NormalisedB|False",
  "WEATHERSUN_N_EARLYCLR-NormalisedR|False",
  "WEATHERSUN_N_EARLYCLR-NormalisedG|False",
  "WEATHERSUN_N_EARLYCLR-NormalisedB|False",
  "WEATHERSUN_NCLR-NormalisedR|False",
  "WEATHERSUN_NCLR-NormalisedG|False",
  "WEATHERSUN_NCLR-NormalisedB|False",
  "WEATHERSUN_N_LATECLR-NormalisedR|False",
  "WEATHERSUN_N_LATECLR-NormalisedG|False",
  "WEATHERSUN_N_LATECLR-NormalisedB|False",
  "WEATHERRAIN_MCLR-NormalisedR|False",
  "WEATHERRAIN_MCLR-NormalisedG|False",
  "WEATHERRAIN_MCLR-NormalisedB|False",
  "WEATHERRAIN_DCLR-NormalisedR|False",
  "WEATHERRAIN_DCLR-NormalisedG|False",
  "WEATHERRAIN_DCLR-NormalisedB|False",
  "WEATHERRAIN_ECLR-NormalisedR|False",
  "WEATHERRAIN_ECLR-NormalisedG|False",
  "WEATHERRAIN_ECLR-NormalisedB|False",
  "WEATHERRAIN_N_EARLYCLR-NormalisedR|False",
  "WEATHERRAIN_N_EARLYCLR-NormalisedG|False",
  "WEATHERRAIN_N_EARLYCLR-NormalisedB|False",
  "WEATHERRAIN_NCLR-NormalisedR|False",
  "WEATHERRAIN_NCLR-NormalisedG|False",
  "WEATHERRAIN_NCLR-NormalisedB|False",
  "WEATHERRAIN_N_LATECLR-NormalisedR|False",
  "WEATHERRAIN_N_LATECLR-NormalisedG|False",
  "WEATHERRAIN_N_LATECLR-NormalisedB|False",
  "PTREE_4\\10\\PTVALS1Clone|False",
  "PTREE_4\\10\\PTVALS2Clone|False",
  "PTREE_4\\10\\PTVALS3Clone|False",
  "CHARA_LGT_E_CLR-NormalisedR|False",
  "CHARA_LGT_E_CLR-NormalisedG|False",
  "CHARA_LGT_E_CLR-NormalisedB|False",
  "CHARA_LGT_CLR-NormalisedR|False",
  "CHARA_LGT_CLR-NormalisedG|False",
  "CHARA_LGT_CLR-NormalisedB|False",
  "UnkFloat97|False",
  "UnkFloat98|False",
  "UnkFloat99|False",
  "PTREE_4\\13\\PTVALS1|False",
  "PTREE_4\\13\\PTVALS2|False",
  "PTREE_4\\13\\PTVALS3|False",
  "Unk103Greyscale??|False",
  "BgImgA|False",
  "BgImgB|False",
  "BgImgC|False",
  "BgImgD|False",
  "BgImgE|False",
  "BgImgF|False",
  "BgImgF_2?|False",
  "BgImgG|False",
  "BgImgH|False",
  "BgImgI|False",
  "BgImgJ|False",
  "BgImgK|False",
  "BgImgL|False",
  "BgImgL_2?|False",
  "Fog??|False",
  "Unk119|False",
  "Unk120|False",
  "Unk121|False",
  "Unk122|False",
  "Unk123|False",
  "Unk124|False",
  "Unk125|False",
  "MaybeCameraRelated?|False",
  "Unk127|False",
  "Unk128|False",
  "Unk129|False",
  "Unk130|False",
  "Unk131|False"
];


// YWB labels array
const LABELS_YWB = [
  "ActivationCond",
  "MapEffectMORNING_DAY?",
  "MapEffectEVENING?",
  "MapEffectNIGHT?",
  "MapEffectRAIN?",
  "MapEffectFORCE???",
  "MMScroll",
  "MMModelPos-X?",
  "MMModelPos-Y?",
  "MMModelPos-Z?",
  "MMModelPos-ROT?",
  "UnkX??????",
  "UnkY??????",
  "UnkZ??????",
  "UnkRot??????",
  "MMViewSize-PixelsX",
  "MMViewSize-PixelsY",
  "CameraFOV",
  "CameraDist",
  "CameraRotH",
  "CameraRotV",
  "CameraRotUnk",
  "CameraRotAlsoUnk",
  "DptRngRate",
  "DptLvl",
  "Near",
  "Far",
  "LIGHTMapLight",
  "LIGHTBGColorNormalisedR",
  "LIGHTBGColorNormalisedG",
  "LIGHTBGColorNormalisedB",
  "ShadowColsdw01-NormalisedR",
  "ShadowColsdw01-NormalisedG",
  "ShadowColsdw01-NormalisedB",
  "ShadowColsdw02-NormalisedR",
  "ShadowColsdw02-NormalisedG",
  "ShadowColsdw02-NormalisedB",
  "ShadowColsdw03-NormalisedR",
  "ShadowColsdw03-NormalisedG",
  "ShadowColsdw03-NormalisedB",
  "ShadowColsdw04-NormalisedR",
  "ShadowColsdw04-NormalisedG",
  "ShadowColsdw04-NormalisedB",
  "ShadowColsdw05-NormalisedR",
  "ShadowColsdw05-NormalisedG",
  "ShadowColsdw05-NormalisedB",
  "DEF_POSX?",
  "DEF_POSY?",
  "DEF_POSZ?",
  "DEF_POSROT?",
  "UnkBoolMaybeINDOOR-BooleanIsIndoors?????",
  "WEATHERSUN_MCLR-NormalisedR",
  "WEATHERSUN_MCLR-NormalisedG",
  "WEATHERSUN_MCLR-NormalisedB",
  "WEATHERSUN_DCLR-NormalisedR",
  "WEATHERSUN_DCLR-NormalisedG",
  "WEATHERSUN_DCLR-NormalisedB",
  "WEATHERSUN_ECLR-NormalisedR",
  "WEATHERSUN_ECLR-NormalisedG",
  "WEATHERSUN_ECLR-NormalisedB",
  "WEATHERSUN_N_EARLYCLR-NormalisedR",
  "WEATHERSUN_N_EARLYCLR-NormalisedG",
  "WEATHERSUN_N_EARLYCLR-NormalisedB",
  "WEATHERSUN_NCLR-NormalisedR",
  "WEATHERSUN_NCLR-NormalisedG",
  "WEATHERSUN_NCLR-NormalisedB",
  "WEATHERSUN_N_LATECLR-NormalisedR",
  "WEATHERSUN_N_LATECLR-NormalisedG",
  "WEATHERSUN_N_LATECLR-NormalisedB",
  "WEATHERRAIN_MCLR-NormalisedR",
  "WEATHERRAIN_MCLR-NormalisedG",
  "WEATHERRAIN_MCLR-NormalisedB",
  "WEATHERRAIN_DCLR-NormalisedR",
  "WEATHERRAIN_DCLR-NormalisedG",
  "WEATHERRAIN_DCLR-NormalisedB",
  "WEATHERRAIN_ECLR-NormalisedR",
  "WEATHERRAIN_ECLR-NormalisedG",
  "WEATHERRAIN_ECLR-NormalisedB",
  "WEATHERRAIN_N_EARLYCLR-NormalisedR",
  "WEATHERRAIN_N_EARLYCLR-NormalisedG",
  "WEATHERRAIN_N_EARLYCLR-NormalisedB",
  "WEATHERRAIN_NCLR-NormalisedR",
  "WEATHERRAIN_NCLR-NormalisedG",
  "WEATHERRAIN_NCLR-NormalisedB",
  "WEATHERRAIN_N_LATECLR-NormalisedR",
  "WEATHERRAIN_N_LATECLR-NormalisedG",
  "WEATHERRAIN_N_LATECLR-NormalisedB",
  "Unk1",
  "Unk2",
  "Unk3",
  "CHARA_LGT_E_CLR-NormalisedR",
  "CHARA_LGT_E_CLR-NormalisedG",
  "CHARA_LGT_E_CLR-NormalisedB",
  "CHARA_LGT_CLR-NormalisedR",
  "CHARA_LGT_CLR-NormalisedG",
  "CHARA_LGT_CLR-NormalisedB",
  "UnkFloat?1?",
  "UnkFloat?2?",
  "UnkFloat?3?",
  "Unk4",
  "Unk5",
  "Unk6",
  "Unk7-Greyscale?????",
  "BgImgA?",
  "BgImgB?",
  "BgImgC?",
  "BgImgD?",
  "BgImgE?",
  "BgImgF?",
  "BgImgG??",
  "BgImgH??",
  "BgImgI??",
  "BgImgJ??",
  "BgImgK??",
  "BgImgL??"
];

// ---- utils ----
function readJsonFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      try { resolve(JSON.parse(reader.result)); }
      catch (e) { reject(new Error('Failed to parse JSON: ' + e.message)); }
    };
    reader.onerror = () => reject(new Error('Failed to read file.'));
    reader.readAsText(file);
  });
}

// CRC32 utility (UTF-8)
const CRC32_TABLE = (function(){
  const t = new Uint32Array(256);
  for(let i=0;i<256;i++){
    let c=i;
    for(let j=0;j<8;j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    t[i]=c>>>0;
  }
  return t;
})();
function crc32str(s){
  if(s == null) return 0;
  const enc = new TextEncoder();
  const bytes = enc.encode(String(s));
  let crc = 0xFFFFFFFF;
  for(const b of bytes) crc = (crc >>> 8) ^ CRC32_TABLE[(crc ^ b) & 0xFF];
  return (crc ^ 0xFFFFFFFF) >>> 0;
}

// Build a hierarchical map from PTREE/PTVAL entries
function buildPathMap(yw2){
  const stack = [];
  const map = new Map(); // key -> array-of-arrays (each PTVAL group preserved)

  for(const node of yw2){
    const name = String(node.Name || '').toUpperCase();

    if(name === 'PTREE'){
      for(const v of node.Values || []){
        if(v && v.Type === 0) stack.push(String(v.Value));
      }
    } else if(name === '_PTREE'){
      if(stack.length > 0) stack.pop();
    } else if(name === 'PTVAL' || name === 'PTVALS'){
      const parsed = (node.Values || []).map(v => {
        if(!v) return null;
        if(v.Type === 0) return String(v.Value);
        if(v.Type === 1) return Number.isFinite(v.Value) ? parseInt(v.Value, 10) : Number(v.Value);
        if(v.Type === 2) return Number(v.Value);
        return v.Value;
      });
      const key = stack.join('/') || 'ROOT';
      if(!map.has(key)) map.set(key, []);
      map.get(key).push(parsed);
    }
  }

  return map;
}

// Find the first path whose path-tokens contain the given tokens in sequential order
function findPathValues(map, tokens){
  if(!Array.isArray(tokens)) tokens = [tokens];
  const tokensU = tokens.map(t => String(t).toUpperCase());

  for(const [path, lists] of map.entries()){
    const parts = path.split('/').filter(Boolean).map(p => p.toUpperCase());
    let idx = 0, ok = true;
    for(const tok of tokensU){
      const pos = parts.indexOf(tok, idx);
      if(pos === -1){ ok = false; break; }
      idx = pos + 1;
    }
    if(!ok) continue;
    return lists.flat();
  }
  return null;
}

function findValueByTokenFallback(map, token){
  const tokenU = String(token).toUpperCase();
  for(const [key, lists] of map.entries()){
    if(key.toUpperCase().endsWith(tokenU)){
      return lists.flat();
    }
  }
  return null;
}


// Robust color extraction: returns [R,G,B]
function getColorComponents(map, baseTokens){
  const arr = findPathValues(map, baseTokens);
  if(arr && arr.length >= 3) return [arr[0], arr[1], arr[2]];

  const baseUpper = baseTokens.map(t => String(t).toUpperCase()).join('/');
  for(const [key, lists] of map.entries()){
    const ku = key.toUpperCase();
    if(ku.endsWith(baseUpper)){
      const flat = [];
      for(const a of lists) for(const v of a) if(typeof v === 'number') flat.push(v);
      if(flat.length >= 3) return [flat[0], flat[1], flat[2]];
    }
  }

  const comps = [];
  const rgs = ['R','G','B'];
  for(const c of rgs){
    let found = null;
    const candidates = ["/"+c, "-"+c, "_"+c, c];
    for(const [key, lists] of map.entries()){
      const ku = key.toUpperCase();
      for(const cand of candidates){
        if(ku.endsWith(baseUpper + cand) || ku.endsWith('/' + baseUpper + cand)){
          for(const a of lists){
            for(const v of a) if(typeof v === 'number'){ found = v; break; }
            if(found !== null) break;
          }
        }
        if(found !== null) break;
      }
      if(found !== null) break;
    }
    if(found === null){
      for(const [key, lists] of map.entries()){
        const ku = key.toUpperCase();
        if(ku.endsWith(baseUpper)){
          const flat = [];
          for(const a of lists) for(const v of a) if(typeof v === 'number') flat.push(v);
          if(flat.length > 0){ found = flat[0]; break; }
        }
      }
    }
    comps.push(found === null ? 0 : found);
  }

  return comps;
}

// Robust shadow extraction (pads sdw number to 2 digits)
function getShadowComponent(map, sdwNum, compIndex){
  const sdwKey = 'sdw' + String(sdwNum).padStart(2,'0') + '-';
  let arr = findPathValues(map, ['LIGHT', 'ShadowCol', sdwKey]);
  if(arr && arr.length > compIndex) return arr[compIndex];

  for(const [key, lists] of map.entries()){
    if(key.toUpperCase().endsWith(sdwKey.toUpperCase())){
      const flat = [];
      for(const a of lists) for(const v of a) if(typeof v === 'number') flat.push(v);
      if(flat.length > compIndex) return flat[compIndex];
    }
  }

  for(const [key, lists] of map.entries()){
    if(key.toUpperCase().includes('SHADOWCOL')){
      const flat = [];
      for(const a of lists) for(const v of a) if(typeof v === 'number') flat.push(v);
      if(flat.length > compIndex) return flat[compIndex];
    }
  }

  return 0;
}

// Extract LIGHT MapLight string
function getLightMapLight(map){
  // 1) direct path search
  let arr = findPathValues(map, ['LIGHT','MapLight']);
  if(arr && arr.length>0){
    // pick first string value from flattened values
    for(const v of arr) if(typeof v === 'string') return v;
  }

  // 2) search for keys that include '/LIGHT/MAPLIGHT' (case-insensitive)
  for(const [key, lists] of map.entries()){
    if(key.toUpperCase().includes('/LIGHT/MAPLIGHT')){
      const flat = lists.flat();
      for(const v of flat) if(typeof v === 'string') return v;
    }
  }

  // 3) search PTVAL groups under any LIGHT path and try to find a string token (fallback)
  for(const [key, lists] of map.entries()){
    if(!key.toUpperCase().includes('LIGHT')) continue;
    for(const a of lists){
      for(const v of a) if(typeof v === 'string' && v.toUpperCase() !== 'MAPLIGHT') return v;
    }
  }

  // 4) any PTVAL group that explicitly labels 'MapLight' -> neighbor
  for(const lists of map.values()){
    for(const a of lists){
      const idx = a.findIndex(x => typeof x === 'string' && x.toUpperCase() === 'MAPLIGHT');
      if(idx !== -1){
        if(a.length > idx+1 && typeof a[idx+1] === 'string') return a[idx+1];
      }
    }
  }

  return 0;
}

function attemptBtlMapId(map){
  for(const lists of map.values()){
    for(const arr of lists){
      const hasLabel = arr.some(v => typeof v === 'string' && v.toUpperCase() === 'BTLMAPID');
      if(hasLabel){
        for(const v of arr) if(typeof v === 'string' && v.toUpperCase() !== 'BTLMAPID') return v;
      }
    }
  }
  for(const lists of map.values()){
    for(const arr of lists){
      for(const v of arr){
        if(typeof v === 'string' && /^t\d.*b/i.test(v)) return v;
      }
    }
  }
  return null;
}

function makeOutEntry(val){
  if(typeof val === 'string') return {Type:0, Value: val};
  if(typeof val === 'number' && !Number.isNaN(val)) return Number.isInteger(val) ? {Type:1, Value: val} : {Type:2, Value: val};
  return {Type:1, Value: 0};
}

// Main mapping logic returns values array and map object
function generateValues(yw2, labels){
  const map = buildPathMap(yw2);
  const out = [];

  for(const lab of labels){
    const name = lab.split('|')[0];
    const n = String(name).toUpperCase();
    let val = null;

    // forced defaults
    if(n === 'CAMERAROTUNK') val = -45;
    else if(n === 'CAMERAROTALSOUNK') val = 45;
    else if(n === 'MAYBECAMERARELATED?') val = 35;
    else if(n === 'BTLMAPID'){
      val = attemptBtlMapId(map) || 0;
    } else if(n === 'LIGHTMAPLIGHT'){
      val = getLightMapLight(map) || 0;
    } else if(n.startsWith('LIGHTBGCOLORNORMALISED')){
      const comps = getColorComponents(map, ['LIGHT','BGColor']);
      const compIndex = n.endsWith('R') ? 0 : (n.endsWith('G') ? 1 : 2);
      val = comps[compIndex] ?? 0;
    } else if(n.startsWith('SHADOWCOLSDW')){
      const m = n.match(/SDW0*([0-9]+)/);
      const comp = n.endsWith('R') ? 0 : (n.endsWith('G') ? 1 : 2);
      if(m){
        const sdwNum = parseInt(m[1], 10);
        val = getShadowComponent(map, sdwNum, comp);
      } else val = 0;
    } else if(n.startsWith('MMMODELPOS')){
      const arr = findPathValues(map, ['MMModelPos']);
      if(arr){
        if(n.includes('X')) val = arr[0] ?? 0;
        else if(n.includes('Y')) val = arr[1] ?? 0;
        else if(n.includes('Z')) val = arr[2] ?? 0;
        else if(n.includes('ROT')) val = arr[3] ?? 0;
        else val = arr[0] ?? 0;
      } else val = 0;
} else if (n.startsWith('INDOOR')) {
  let arr = findPathValues(map, ['INDOOR']); // match PTREE value, not full label
  if(!arr){
    // fallback: any key that includes "INDOOR"
    for(const [key, lists] of map.entries()){
      if(key.toUpperCase().includes('INDOOR')){
        arr = lists.flat();
        break;
      }
    }
  }
  val = arr?.[0] ?? 0;
    } else if(n === 'CAMERAFOV'){
      const arr = findPathValues(map, ['CAMERA', 'Fov']); val = arr ? arr[0] : 0;
    } else if(n === 'CAMERADIST'){
      const arr = findPathValues(map, ['CAMERA', 'Dist']); val = arr ? arr[0] : 0;
    } else if(n === 'CAMERAROTH'){
      const arr = findPathValues(map, ['CAMERA', 'RotH']); val = arr ? arr[0] : 0;
    } else if(n === 'CAMERAROTV'){
      const arr = findPathValues(map, ['CAMERA', 'RotV']); val = arr ? arr[0] : 0;
    } else if(n === 'DPTRNGRATE'){
      let arr = findPathValues(map, ['CAMERA', 'DptRngRate']); if(!arr) arr = findPathValues(map, ['DptRngRate']); val = arr ? arr[0] : 0;
    } else if(n === 'DPTLVL'){
      let arr = findPathValues(map, ['CAMERA', 'DptLvl']); if(!arr) arr = findPathValues(map, ['DptLvl']); val = arr ? arr[0] : 0;
    } else if(n === 'NEAR'){
      let arr = findPathValues(map, ['CAMERA', 'Near']); if(!arr) arr = findPathValues(map, ['Near']); val = arr ? arr[0] : 0;
    } else if(n === 'FAR'){
      let arr = findPathValues(map, ['CAMERA', 'Far']); if(!arr) arr = findPathValues(map, ['Far']); val = arr ? arr[0] : 0;
    } else if(n.startsWith('WEATHERSUN')){
      const comp = n.endsWith('R') ? 0 : (n.endsWith('G') ? 1 : 2);
      const mapping = {MCLR: 'SUN_M/CLR', DCLR: 'SUN_D/CLR', ECLR: 'SUN_E/CLR', N_EARLYCLR: 'SUN_N_EARLY/CLR', NCLR: 'SUN_N/CLR', N_LATECLR: 'SUN_N_LATE/CLR'};
      let core = n.replace('WEATHERSUN_', '');
      let matchKey = null;
      for(const k of Object.keys(mapping)) if(core.includes(k)) matchKey = k;
      if(matchKey){
        const parts = mapping[matchKey].split('/');
        const arr = findPathValues(map, ['WEATHER', ...parts]);
        val = arr && arr.length > comp ? arr[comp] : 0;
      } else val = 0;
    } else if(n.startsWith('WEATHERRAIN')){
      const comp = n.endsWith('R') ? 0 : (n.endsWith('G') ? 1 : 2);
      const mapping = {MCLR: 'RAIN_M/CLR', DCLR: 'RAIN_D/CLR', ECLR: 'RAIN_E/CLR', N_EARLYCLR: 'RAIN_N_EARLY/CLR', NCLR: 'RAIN_N/CLR', N_LATECLR: 'RAIN_N_LATE/CLR'};
      let core = n.replace('WEATHERRAIN_', '');
      let matchKey = null;
      for(const k of Object.keys(mapping)) if(core.includes(k)) matchKey = k;
      if(matchKey){
        const parts = mapping[matchKey].split('/');
        const arr = findPathValues(map, ['WEATHER', ...parts]);
        val = arr && arr.length > comp ? arr[comp] : 0;
      } else val = 0;
    } else if(n.startsWith('CHARA_LGT')){
      const comp = n.endsWith('R') ? 0 : (n.endsWith('G') ? 1 : 2);
      const path = (n.includes('E_CLR') || n.includes('CHARA_LGT_E')) ? ['CHARA_LGT_E', 'CLR'] : ['CHARA_LGT', 'CLR'];
      const arr = findPathValues(map, path);
      val = arr && arr.length > comp ? arr[comp] : 0;
    } else if (n.startsWith('DEF_POS')) {
       const arr = findPathValues(map, ['DEF_POS']);
       if (arr && arr.length >= 4) {
       if (n.includes('X'))      val = arr[0];
       else if (n.includes('Y')) val = arr[1];
        else if (n.includes('Z')) val = arr[2];
        else if (n.includes('ROT')) val = arr[3];
      else val = arr[0];
  } else val = 0;
} else if (/^BGIMG/i.test(n)) {
  let arr = findPathValues(map, ['BGIMG']); // PTREE "BgImg"
  if(arr) arr = arr.flat();

  let val = 0;

  if(n.endsWith('_2')) {
    // Find normal label name
    const normalLabel = n.replace(/_2$/i, '');
    // Find the index of normal label in labels array
    const normalIndex = labels.findIndex(lab => lab.split('|')[0].toUpperCase() === normalLabel.toUpperCase());
    if(normalIndex !== -1) val = out[normalIndex]?.Value ?? 0;
  } else {
    // Determine index based on letter A–L
    const match = n.match(/^BgImg([A-L])/i);
    if(match) {
      const index = match[1].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
      val = arr?.[index] ?? 0;
    }
  }

  out.push(makeOutEntry(val));
  continue;
} else if(n.startsWith('MMhwhdskhkadshhkads')){
      const arr = findPathValues(map, ['HGJJGJGGGUYI']);
      if(arr){
        if(n.includes('X')) val = arr[0] ?? 0;
        else if(n.includes('Y')) val = arr[1] ?? 0;
        else if(n.includes('Z')) val = arr[2] ?? 0;
        else if(n.includes('ROT')) val = arr[3] ?? 0;
        else val = arr[0] ?? 0;
      } else val = 0;
    } else {
      let arr = findPathValues(map, [name]);
      if(!arr){
        for(const lists of map.values()){
          for(const a of lists){
            const idx = a.findIndex(x => typeof x === 'string' && x.toUpperCase() === name.toUpperCase());
            if(idx !== -1){
              if(a.length > idx+1){ arr = [a[idx+1]]; break; }
              for(const el of a) if(!(typeof el === 'string' && el.toUpperCase() === name.toUpperCase())){ arr = [el]; break; }
            }
          }
          if(arr) break;
        }
      }
      val = arr ? arr[0] : 0;
    }

    if(typeof val === 'number' && Math.abs(val - Math.round(val)) < 1e-9) val = Math.round(val);
    out.push(makeOutEntry(val));
  }

  return { values: out, map };
}

// NOTE: This computes CRC from the 2nd PTREE token in the first MAP_ENV path (e.g. "t101i01")
function buildNestedInfoSequenceYW3(map, values) {
  // compute crc from the 2nd PTREE token of the first MAP_ENV path
  let crcSource = null;
  for (const key of map.keys()) {
    const up = key.toUpperCase();
    if (up.startsWith('MAP_ENV/')) {
      const parts = key.split('/').filter(Boolean);
      if (parts.length >= 2) {
        crcSource = parts[1]; // second token
        break;
      }
    }
  }

  const crc = crc32str(crcSource);

  // Sequence: LIST_BEG, MAP_ENV_INFO, CNF_LIST_BEG, MAP_ENV_INFO_CNF, CNF_LIST_END, LIST_END
  const seq = [];
  seq.push({ Name: 'MAP_ENV_INFO_LIST_BEG', Values: [{ Type: 1, Value: 1 }] });
  seq.push({ Name: 'MAP_ENV_INFO', Values: [{ Type: 1, Value: crc }] });
  seq.push({ Name: 'MAP_ENV_INFO_CNF_LIST_BEG', Values: [{ Type: 1, Value: 1 }] });
  seq.push({ Name: 'MAP_ENV_INFO_CNF', Values: values });
  seq.push({ Name: 'MAP_ENV_INFO_CNF_LIST_END', Values: [] });
  seq.push({ Name: 'MAP_ENV_INFO_LIST_END', Values: [] });

  return seq;
}


function buildNestedInfoSequenceYWB(map, values) {
  return buildNestedInfoSequenceYW3(map, values); // wrapper for now
}

function buildNestedInfoSequence(map, values) {
  const mode = document.getElementById('convert-mode').value;
  return mode === 'ywb'
    ? buildNestedInfoSequenceYWB(map, values)
    : buildNestedInfoSequenceYW3(map, values);
}
// UI handler
async function handleConvert() {
  const f = document.getElementById('file-yw2').files[0];
  if (!f) { alert('Please select a yw2 JSON file'); return; }

  try {
    const yw2 = await readJsonFile(f);
    if (!Array.isArray(yw2)) throw new Error('Unexpected file format: expected top-level array of nodes');

    // --- RUN THIS LAST ---
    const mode = document.getElementById('convert-mode').value;
    const labels = mode === 'ywb' ? LABELS_YWB : LABELS_YW3;
    const { values, map } = generateValues(yw2, labels);
    const seq = buildNestedInfoSequence(map, values);

    const blob = new Blob([JSON.stringify(seq, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const dl = document.getElementById('download');
    dl.href = url;
    dl.download = f.name.replace(/\.json$/, '') + '-to-' + mode + '.json';
    dl.style.display = 'inline';
    dl.textContent = 'Download converted JSON';

    document.getElementById('preview').textContent =
      'Converted preview:\n' + JSON.stringify(seq, null, 2).slice(0, 1000) + '...';
  } catch (err) {
    alert('Error: ' + (err && err.message ? err.message : String(err)));
    console.error(err);
  }
}


document.getElementById('convert').addEventListener('click', handleConvert);
</script>
</body>
</html>
